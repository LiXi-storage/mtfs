Index: swgfs-1.8.1.1/swgfs/include/swgfs/swgfs_idl.h
===================================================================
--- swgfs-1.8.1.1.orig/swgfs/include/swgfs/swgfs_idl.h
+++ swgfs-1.8.1.1/swgfs/include/swgfs/swgfs_idl.h
@@ -640,6 +640,75 @@ struct lov_mds_md_v3 {            /* LOV
 #define OBD_MD_FLUSAGE      OBD_MD_FLUSRQUOTA /* file open count */
 #endif
 
+#ifndef LIXI_20110807
+
+/*
+ * Same to macros defined in hrfs/include/debug.h
+ */
+#if 1
+#define HDEBUG(format, args...) CDEBUG(D_INFO, "hrfs_swgfs: "format, ##args)
+#else
+#define HDEBUG(format, args...) CERROR("hrfs_swgfs: "format, ##args)
+#endif
+#define HERROR(format, args...) CERROR("hrfs_swgfs: "format, ##args)
+#define HWARN(format, args...) CERROR("hrfs_swgfs: "format, ##args)
+#define HPRINT(format, args...) CERROR("hrfs_swgfs: "format, ##args)
+
+/*
+ * Same to macros defined in hrfs/include/hrfs_common.h
+ * We should keep this ture:
+ * When flag is zero by default,
+ * it means file data is proper and not under recovering.
+ * Lowest 4 bits are for raid_pattern.
+ */
+#define HRFS_FLAG_PRIMARY                0x00000010
+#define HRFS_FLAG_DATABAD                0x00000020
+#define HRFS_FLAG_RECOVERING             0x00000040
+#define HRFS_FLAG_SETED                  0x00000080
+
+#define HRFS_FLAG_MDS_MASK               0x000000ff
+#define HRFS_FLAG_MDS_SYMBOL             0xc0ffee00
+
+static inline int hrfs_flag_is_valid(__u32 hrfs_flag)
+{
+        int rc = 0;
+
+        if (((hrfs_flag & HRFS_FLAG_SETED) == 0) &&
+            (hrfs_flag != 0)) {
+                /* If not seted, then it is zero */
+                goto out;
+        }
+
+        if ((hrfs_flag & (~HRFS_FLAG_MDS_MASK)) != 0) {
+                /* Should not set unused flag*/
+                goto out;
+        }
+
+        if ((hrfs_flag & HRFS_FLAG_RECOVERING) &&
+            (!(hrfs_flag & HRFS_FLAG_DATABAD))) {
+            	/* Branch being recovered should be bad*/
+            	goto out;
+        }
+        rc = 1;
+out:
+        return rc;
+}
+
+static inline int mds_hrfs_flag_is_valid(__u32 mds_hrfs_flag)
+{
+        int rc = 0;
+        __u32 hrfs_flag = mds_hrfs_flag & HRFS_FLAG_MDS_MASK;
+
+        if ((mds_hrfs_flag & (~HRFS_FLAG_MDS_MASK)) != HRFS_FLAG_MDS_SYMBOL) {
+                goto out;
+        }
+
+        rc = hrfs_flag_is_valid(hrfs_flag);
+out:
+        return rc;
+}
+#endif /* LIXI_20110807 */
+
 /* don't forget obdo_fid which is way down at the bottom so it can
  * come after the definition of llog_cookie */
 
Index: swgfs-1.8.1.1/swgfs/llite/file.c
===================================================================
--- swgfs-1.8.1.1.orig/swgfs/llite/file.c
+++ swgfs-1.8.1.1/swgfs/llite/file.c
@@ -801,6 +801,31 @@ int ll_page_removal_cb(void *data, int d
                 GOTO(out, rc = 0);
 
         mapping = page->mapping;
+
+#ifndef LIXI_20110331
+        {
+                struct inode *inode = mapping->host;
+
+                if (inode) {
+                        struct ll_inode_info *lli = ll_i2info(inode);
+                        struct hrfs_idata *hrfs_idata = &(lli->lli_hrfs_idata);
+                        struct inode * parent_inode = hrfs_idata->hi_parent;
+                        if (parent_inode && hi_is_primary_and_proper(hrfs_idata)) {
+                                struct address_space *parent_mapping = parent_inode->i_mapping;
+                                unsigned long parent_page_index = page->index;
+                                struct page *parent_page = find_get_page(parent_mapping, parent_page_index);
+
+                                /* Simply ClearPageUptodate() the whole page. Is there any way to improve? */
+                        		if (parent_page) {
+                        		        	lock_page(parent_page);
+                        		        	ClearPageUptodate(parent_page);
+                        		        	unlock_page(parent_page);
+                        		}
+                        }
+                }
+        }
+#endif
+
 /* ZX201101 */
 #ifdef HAVE_RAID_PATTERN_SUPPORT
         rc = 0;
@@ -4701,3 +4726,772 @@ enum llioc_iter ll_iocontrol_call(struct
                 *rcp = rc;
         return ret;
 }
+
+#ifndef LIXI_20110331
+/* Be the same with struct hrfs_file_branch defined in hrfs/file.h */
+typedef struct hrfs_file_branch {
+	int is_used;
+	int is_valid;
+	struct file *bfile;
+} hrfs_f_branch_t;
+
+struct iovec *iov_alloc(unsigned long nr_segs)
+{
+        struct iovec *iov = NULL;
+        OBD_ALLOC(iov, sizeof(*iov) * nr_segs);
+
+        return iov;
+}
+
+void iov_free(struct iovec *iov, unsigned long nr_segs)
+{
+        OBD_FREE(iov, sizeof(*iov) * nr_segs);
+
+        return;
+}
+
+void iov_cpy(struct iovec *dest, struct iovec *src, unsigned long nr_segs)
+{
+        memcpy(dest, src, sizeof(struct iovec) * nr_segs);
+}
+
+struct iovec *iov_dup(struct iovec *src, unsigned long nr_segs)
+{
+        struct iovec *dest = NULL;
+
+        dest = iov_alloc(nr_segs);
+        if (dest != NULL) {
+                iov_cpy(dest, src, nr_segs);
+        }
+
+        return dest;
+}
+
+static ssize_t ll_hrfs_file_readv(struct file *parent_file, int b_remain, hrfs_f_branch_t *barray, const struct iovec *iov,
+                              unsigned long nr_segs, loff_t *ppos)
+{
+#ifndef LIXI_20110722
+        struct file *file = barray[0].bfile;
+#endif
+        struct inode *inode = file->f_dentry->d_inode;
+        struct ll_inode_info *lli = ll_i2info(inode);
+        struct lov_stripe_md *lsm = lli->lli_smd;
+        struct ll_sb_info *sbi = ll_i2sbi(inode);
+        struct ll_lock_tree tree;
+        struct ost_lvb lvb;
+        struct ll_ra_read bead;
+        int ra = 0;
+        obd_off end;
+        ssize_t retval, chunk, sum = 0;
+        int lock_style;
+        struct iovec *iov_copy = NULL;
+        unsigned long nrsegs_copy, nrsegs_orig = 0;
+        size_t count, iov_offset = 0;
+        __u64 kms;
+        void *cookie;
+        ENTRY;
+
+        count = ll_file_get_iov_count(iov, &nr_segs);
+        CDEBUG(D_VFSTRACE, "VFS Op:inode=%lu/%u(%p),size="LPSZ",offset=%Ld\n",
+               inode->i_ino, inode->i_generation, inode, count, *ppos);
+        /* "If nbyte is 0, read() will return 0 and have no other results."
+         *                      -- Single Unix Spec */
+        if (count == 0)
+                RETURN(0);
+
+        ll_stats_ops_tally(sbi, LPROC_LL_READ_BYTES, count);
+
+        if (!lsm) {
+                /* Read on file with no objects should return zero-filled
+                 * buffers up to file size (we can get non-zero sizes with
+                 * mknod + truncate, then opening file for read. This is a
+                 * common pattern in NFS case, it seems). Bug 6243 */
+                int notzeroed;
+                /* Since there are no objects on OSTs, we have nothing to get
+                 * lock on and so we are forced to access inode->i_size
+                 * unguarded */
+
+                /* Read beyond end of file */
+                if (*ppos >= i_size_read(inode))
+                        RETURN(0);
+
+                if (count > i_size_read(inode) - *ppos)
+                        count = i_size_read(inode) - *ppos;
+                /* Make sure to correctly adjust the file pos pointer for
+                 * EFAULT case */
+                for (nrsegs_copy = 0; nrsegs_copy < nr_segs; nrsegs_copy++) {
+                        const struct iovec *iv = &iov[nrsegs_copy];
+
+                        if (count < iv->iov_len)
+                                chunk = count;
+                        else
+                                chunk = iv->iov_len;
+                        notzeroed = clear_user(iv->iov_base, chunk);
+                        sum += (chunk - notzeroed);
+                        count -= (chunk - notzeroed);
+                        if (notzeroed || !count)
+                                break;
+                }
+                *ppos += sum;
+                if (!sum)
+                        RETURN(-EFAULT);
+                RETURN(sum);
+        }
+
+repeat:
+        if (sbi->ll_max_rw_chunk != 0 && !(file->f_flags & O_DIRECT)) {
+                /* first, let's know the end of the current stripe */
+                end = *ppos;
+                obd_extent_calc(sbi->ll_osc_exp, lsm, OBD_CALC_STRIPE_END,&end);
+
+                /* correct, the end is beyond the request */
+                if (end > *ppos + count - 1)
+                        end = *ppos + count - 1;
+
+                /* and chunk shouldn't be too large even if striping is wide */
+                if (end - *ppos > sbi->ll_max_rw_chunk)
+                        end = *ppos + sbi->ll_max_rw_chunk - 1;
+
+                chunk = end - *ppos + 1;
+                if ((count == chunk) && (iov_offset == 0)) {
+                        if (iov_copy)
+                                OBD_FREE(iov_copy, sizeof(*iov) * nrsegs_orig);
+
+                        iov_copy = (struct iovec *)iov;
+                        nrsegs_copy = nr_segs;
+                } else {
+                        if (!iov_copy) {
+                                nrsegs_orig = nr_segs;
+                                OBD_ALLOC(iov_copy, sizeof(*iov) * nr_segs);
+                                if (!iov_copy)
+                                        GOTO(out, retval = -ENOMEM);
+                        }
+
+                        iov_copy_update(&nr_segs, &iov, &nrsegs_copy, iov_copy,
+                                        &iov_offset, chunk);
+                }
+        } else {
+                end = *ppos + count - 1;
+                iov_copy = (struct iovec *)iov;
+                nrsegs_copy = nr_segs;
+        }
+
+        down_read(&lli->lli_truncate_rwsem); /* Bug 18233 */
+
+        lock_style = ll_file_get_lock(file, (obd_off)(*ppos), end,
+                                      iov_copy, nrsegs_copy, &cookie, &tree,
+                                      OBD_BRW_READ);
+        if (lock_style < 0 || lock_style == LL_LOCK_STYLE_NOLOCK)
+                up_read(&lli->lli_truncate_rwsem);
+        if (lock_style < 0)
+                GOTO(out, retval = lock_style);
+
+        ll_inode_size_lock(inode, 1);
+        /*
+         * Consistency guarantees: following possibilities exist for the
+         * relation between region being read and real file size at this
+         * moment:
+         *
+         *  (A): the region is completely inside of the file;
+         *
+         *  (B-x): x bytes of region are inside of the file, the rest is
+         *  outside;
+         *
+         *  (C): the region is completely outside of the file.
+         *
+         * This classification is stable under DLM lock acquired by
+         * ll_tree_lock() above, because to change class, other client has to
+         * take DLM lock conflicting with our lock. Also, any updates to
+         * ->i_size by other threads on this client are serialized by
+         * ll_inode_size_lock(). This guarantees that short reads are handled
+         * correctly in the face of concurrent writes and truncates.
+         */
+        inode_init_lvb(inode, &lvb);
+        obd_merge_lvb(ll_i2sbi(inode)->ll_osc_exp, lsm, &lvb, 1);
+        kms = lvb.lvb_size;
+        if (*ppos + count - 1 > kms) {
+                /* A glimpse is necessary to determine whether we return a
+                 * short read (B) or some zeroes at the end of the buffer (C) */
+                ll_inode_size_unlock(inode, 1);
+                retval = ll_glimpse_size(inode, LDLM_FL_BLOCK_GRANTED);
+                if (retval) {
+                        if (lock_style != LL_LOCK_STYLE_NOLOCK) {
+                                ll_file_put_lock(inode, end, lock_style,
+                                                 cookie, &tree, OBD_BRW_READ);
+                                up_read(&lli->lli_truncate_rwsem);
+                        }
+                        goto out;
+                } else {
+                        /* If objective page index exceed the end-of-file page
+                         * index, return directly. Do not expect kernel will
+                         * check such case correctly. linux-2.6.18-128.1.1 miss
+                         * to do that. --bug 17336 */
+                        size_t size = i_size_read(inode);
+                        unsigned long cur_index = *ppos >> CFS_PAGE_SHIFT;
+
+                        if ((size == 0 && cur_index != 0) ||
+                            (((size - 1) >> CFS_PAGE_SHIFT) < cur_index)) {
+                                if (lock_style != LL_LOCK_STYLE_NOLOCK) {
+                                        ll_file_put_lock(inode, end, lock_style,
+                                                         cookie, &tree,
+                                                         OBD_BRW_READ);
+                                        up_read(&lli->lli_truncate_rwsem);
+                                }
+                                goto out;
+                        }
+                }
+        } else {
+                /* region is within kms and, hence, within real file size (A).
+                 * We need to increase i_size to cover the read region so that
+                 * generic_file_read() will do its job, but that doesn't mean
+                 * the kms size is _correct_, it is only the _minimum_ size.
+                 * If someone does a stat they will get the correct size which
+                 * will always be >= the kms value here.  b=11081 */
+                if (i_size_read(inode) < kms)
+                        i_size_write(inode, kms);
+                ll_inode_size_unlock(inode, 1);
+        }
+
+        chunk = end - *ppos + 1;
+        CDEBUG(D_INODE,"Read ino %lu, "LPSZ" bytes, offset %lld, i_size %llu\n",
+               inode->i_ino, chunk, *ppos, i_size_read(inode));
+
+        /* turn off the kernel's read-ahead */
+        if (lock_style != LL_LOCK_STYLE_NOLOCK) {
+                /* read under locks
+                 *
+                 * 1. update inode's atime as long as concurrent stat
+                 * (via ll_glimpse_size) might bring out-of-date ones
+                 *
+                 * 2. update lsm so that next stat (via
+                 * ll_glimpse_size) could get correct values in lsm */
+                struct ost_lvb xtimes;
+
+                lov_stripe_lock(lsm);
+                LTIME_S(inode->i_atime) = LTIME_S(CURRENT_TIME);
+                xtimes.lvb_atime = LTIME_S(inode->i_atime);
+                obd_update_lvb(sbi->ll_osc_exp, lsm, &xtimes,
+                               OBD_MD_FLATIME);
+                lov_stripe_unlock(lsm);
+
+                file->f_ra.ra_pages = 0;
+                /* initialize read-ahead window once per syscall */
+                if (ra == 0) {
+                        ra = 1;
+                        ll_ra_read_init(file, &bead, *ppos, count);
+                }
+
+                /* BUG: 5972 */
+                file_accessed(file);
+#ifndef LIXI_20110722
+                {
+                        loff_t pos_tmp = *ppos;
+                        struct iovec *iov_tmp = NULL;
+
+                        HDEBUG("readv begin at branch[%d]\n", b_remain);
+
+                        iov_tmp = iov_dup(iov_copy, nrsegs_copy);
+                        if (iov_tmp == NULL) {
+                        	HERROR("iov_dup() failed at branch[%d], not enough memory\n", b_remain);
+                        	retval = -ENOMEM;
+                        	goto skip_readv;
+                        }
+
+                        retval = generic_file_readv(file, iov_copy, nrsegs_copy, ppos);
+
+                        if (b_remain > 1) {
+                                /* Not last: go deep to other branch */
+                                retval = ll_hrfs_file_readv(parent_file, b_remain - 1,
+                                        &barray[1], iov_tmp, nrsegs_copy, &pos_tmp);
+                        } else {
+                                struct inode *parent_inode = parent_file->f_dentry->d_inode;
+
+                                /* Update parent's inode size*/
+                                if (i_size_read(parent_inode) < kms) {
+                                        HDEBUG("update parent's i_size from %lu to %lu\n",
+                                                (unsigned long)i_size_read(parent_inode), (unsigned long)kms);
+                                        i_size_write(parent_inode, kms);
+                                }
+                                HDEBUG("parent's readv begin, ppos = %lu\n", (unsigned long)pos_tmp);
+#ifdef LIXI_20110725
+                                retval = generic_file_readv(parent_file, iov_tmp, nrsegs_copy, &pos_tmp);
+#endif /* LIXI_20110725 */
+                                HDEBUG("parent's readv end, ret = %ld\n", retval);
+                        }
+#ifdef LIXI_20110725
+                        if (*ppos != pos_tmp) {
+                                if (b_remain > 1) {
+                                        HERROR("unexpected file_pos dismatch: branch[%d] = %lu,  branch[%d] = %lu\n",
+                                                b_remain, (unsigned long)*ppos, b_remain - 1, (unsigned long)pos_tmp);
+                                } else {
+                                        HERROR("unexpected file_pos dismatch: branch[%d] = %lu,  parent = %lu\n",
+                                                b_remain, (unsigned long)*ppos, (unsigned long)pos_tmp);
+                                }
+                                LBUG();
+                        }
+#endif /* LIXI_20110725 */
+                        iov_free(iov_tmp, nrsegs_copy);
+                skip_readv:
+                        HDEBUG("readv end at branch[%d] \n", b_remain);
+                }
+#else /* LIXI_20110722 */
+#ifdef HAVE_FILE_READV
+                retval = generic_file_readv(file, iov_copy, nrsegs_copy, ppos);
+#else
+                retval = generic_file_aio_read(iocb, iov_copy, nrsegs_copy,
+                                               *ppos);
+#endif
+#endif /* LIXI_20110722 */
+                ll_file_put_lock(inode, end, lock_style, cookie,
+                                 &tree, OBD_BRW_READ);
+                up_read(&lli->lli_truncate_rwsem);
+        } else {
+                /* lockless read
+                 *
+                 * current time will get into request as atime
+                 * (swgfs/osc/osc_request.c:osc_build_request())
+                 */
+#ifndef LIXI_20110722
+                HERROR("unexpted lockless readv at branch[%d]\n", b_remain);
+                LBUG();
+                retval = ll_file_lockless_io(file, iov_copy, nrsegs_copy, ppos,
+                                             READ, chunk);
+#else /* LIXI_20110722 */
+                retval = ll_file_lockless_io(file, iov_copy, nrsegs_copy, ppos,
+                                             READ, chunk);
+#endif /* LIXI_20110722 */
+        }
+        ll_rw_stats_tally(sbi, current->pid, file, count, 0);
+        if (retval > 0) {
+                count -= retval;
+                sum += retval;
+                if (retval == chunk && count > 0)
+                        goto repeat;
+        }
+
+ out:
+        if (ra != 0)
+                ll_ra_read_ex(file, &bead);
+        retval = (sum > 0) ? sum : retval;
+
+        if (iov_copy && iov_copy != iov)
+                OBD_FREE(iov_copy, sizeof(*iov) * nrsegs_orig);
+
+        RETURN(retval);
+}
+EXPORT_SYMBOL(ll_hrfs_file_readv);
+
+static ssize_t ll_hrfs_file_writev(struct file *parent_file, int b_remain, hrfs_f_branch_t *barray, const struct iovec *iov,
+                              unsigned long nr_segs, loff_t *ppos)
+{
+#ifndef LIXI_20110722
+        struct file *file = barray[0].bfile;
+#endif
+        struct inode *inode = file->f_dentry->d_inode;
+        struct ll_sb_info *sbi = ll_i2sbi(inode);
+        struct lov_stripe_md *lsm = ll_i2info(inode)->lli_smd;
+        struct ll_lock_tree tree;
+        loff_t maxbytes = ll_file_maxbytes(inode);
+        loff_t lock_start, lock_end, end;
+        ssize_t retval, chunk, sum = 0;
+        int tree_locked;
+        struct iovec *iov_copy = NULL;
+        unsigned long nrsegs_copy, nrsegs_orig = 0;
+        size_t count, iov_offset = 0;
+        ENTRY;
+
+        count = ll_file_get_iov_count(iov, &nr_segs);
+
+        CDEBUG(D_VFSTRACE, "VFS Op:inode=%lu/%u(%p),size="LPSZ",offset=%Ld\n",
+               inode->i_ino, inode->i_generation, inode, count, *ppos);
+
+        SIGNAL_MASK_ASSERT(); /* XXX BUG 1511 */
+
+        /* POSIX, but surprised the VFS doesn't check this already */
+        if (count == 0)
+                RETURN(0);
+
+        /* If file was opened for LL_IOC_LOV_SETSTRIPE but the ioctl wasn't
+         * called on the file, don't fail the below assertion (bug 2388). */
+        if (file->f_flags & O_LOV_DELAY_CREATE &&
+            ll_i2info(inode)->lli_smd == NULL)
+                RETURN(-EBADF);
+
+        LASSERT(ll_i2info(inode)->lli_smd != NULL);
+
+        /* signal(7) specifies that write(2) and writev(2) should be restarted */
+        if (down_interruptible(&ll_i2info(inode)->lli_write_sem))
+                RETURN(-ERESTARTSYS);
+
+repeat:
+        chunk = 0; /* just to fix gcc's warning */
+        end = *ppos + count - 1;
+
+        if (file->f_flags & O_APPEND) {
+                lock_start = 0;
+                lock_end = OBD_OBJECT_EOF;
+                iov_copy = (struct iovec *)iov;
+                nrsegs_copy = nr_segs;
+        } else if (sbi->ll_max_rw_chunk != 0) {
+                /* first, let's know the end of the current stripe */
+                end = *ppos;
+                obd_extent_calc(sbi->ll_osc_exp, lsm, OBD_CALC_STRIPE_END,
+                                (obd_off *)&end);
+
+                /* correct, the end is beyond the request */
+                if (end > *ppos + count - 1)
+                        end = *ppos + count - 1;
+
+                /* and chunk shouldn't be too large even if striping is wide */
+                if (end - *ppos > sbi->ll_max_rw_chunk)
+                        end = *ppos + sbi->ll_max_rw_chunk - 1;
+                lock_start = *ppos;
+                lock_end = end;
+                chunk = end - *ppos + 1;
+                if ((count == chunk) && (iov_offset == 0)) {
+                        if (iov_copy)
+                                OBD_FREE(iov_copy, sizeof(*iov) * nrsegs_orig);
+
+                        iov_copy = (struct iovec *)iov;
+                        nrsegs_copy = nr_segs;
+                } else {
+                        if (!iov_copy) {
+                                nrsegs_orig = nr_segs;
+                                OBD_ALLOC(iov_copy, sizeof(*iov) * nr_segs);
+                                if (!iov_copy)
+                                        GOTO(out, retval = -ENOMEM);
+                        }
+                        iov_copy_update(&nr_segs, &iov, &nrsegs_copy, iov_copy,
+                                        &iov_offset, chunk);
+                }
+        } else {
+                lock_start = *ppos;
+                lock_end = end;
+                iov_copy = (struct iovec *)iov;
+                nrsegs_copy = nr_segs;
+        }
+
+        tree_locked = ll_file_get_tree_lock_iov(&tree, file, iov_copy,
+                                                nrsegs_copy,
+                                                (obd_off)lock_start,
+                                                (obd_off)lock_end,
+                                                OBD_BRW_WRITE);
+        if (tree_locked < 0)
+                GOTO(out, retval = tree_locked);
+
+        /* This is ok, g_f_w will overwrite this under i_sem if it races
+         * with a local truncate, it just makes our maxbyte checking easier.
+         * The i_size value gets updated in ll_extent_lock() as a consequence
+         * of the [0,EOF] extent lock we requested above. */
+        if (file->f_flags & O_APPEND) {
+                *ppos = i_size_read(inode);
+                end = *ppos + count - 1;
+        }
+
+        if (*ppos >= maxbytes) {
+                send_sig(SIGXFSZ, current, 0);
+                GOTO(out_unlock, retval = -EFBIG);
+        }
+        if (end > maxbytes - 1)
+                end = maxbytes - 1;
+
+        /* generic_file_write handles O_APPEND after getting i_mutex */
+        chunk = end - *ppos + 1;
+        CDEBUG(D_INFO, "Writing inode %lu, "LPSZ" bytes, offset %Lu\n",
+               inode->i_ino, chunk, *ppos);
+        if (tree_locked) {
+                /* write under locks
+                 *
+                 * 1. update inode's mtime and ctime as long as
+                 * concurrent stat (via ll_glimpse_size) might bring
+                 * out-of-date ones
+                 *
+                 * 2. update lsm so that next stat (via
+                 * ll_glimpse_size) could get correct values in lsm */
+                struct ost_lvb xtimes;
+
+                lov_stripe_lock(lsm);
+                LTIME_S(inode->i_mtime) = LTIME_S(CURRENT_TIME);
+                LTIME_S(inode->i_ctime) = LTIME_S(CURRENT_TIME);
+                xtimes.lvb_mtime = LTIME_S(inode->i_mtime);
+                xtimes.lvb_ctime = LTIME_S(inode->i_ctime);
+                obd_update_lvb(sbi->ll_osc_exp, lsm, &xtimes,
+                               OBD_MD_FLMTIME | OBD_MD_FLCTIME);
+                lov_stripe_unlock(lsm);
+#ifndef LIXI_20110722
+                {
+                        loff_t pos_tmp = *ppos;
+                        struct iovec *iov_tmp = NULL;
+
+                        HDEBUG("readv begin at branch[%d]\n", b_remain);
+                        iov_tmp = iov_dup(iov_copy, nrsegs_copy);
+                        if (iov_tmp == NULL) {
+                                HERROR("iov_dup() failed at branch[%d], not enough memory\n", b_remain);
+                                retval = -ENOMEM;
+                                goto skip_writev;
+                        }
+
+                        retval = generic_file_writev(file, iov_copy, nrsegs_copy, ppos);
+
+                        if (b_remain > 1) {
+                                /* Not last: go deep to other branch */
+                                if (file->f_flags & O_APPEND) {
+                                        /* Have to set pos to 0 */
+                                        pos_tmp = 0;
+                                }
+                                retval = ll_hrfs_file_writev(parent_file, b_remain - 1, &barray[1],
+                                                                        iov_tmp, nrsegs_copy, &pos_tmp);
+                        } else {
+                                struct inode *parent_inode = parent_file->f_dentry->d_inode;
+
+                                if (parent_file->f_flags & O_APPEND) {
+                                        /* Update i_size */
+                                        i_size_write(parent_inode, pos_tmp);
+                                        /* Have to set pos to 0 */
+                                        pos_tmp = 0;
+                                }
+
+                                HDEBUG("parent's writev begin, ppos = %lu\n", (unsigned long)pos_tmp);
+#ifdef LIXI_20110725
+                                retval = generic_file_writev(parent_file, iov_tmp, nrsegs_copy, &pos_tmp);
+#endif /* LIXI_20110725 */
+                                HDEBUG("parent's writev end, ret = %ld\n", retval);
+                        }
+#ifdef LIXI_20110725
+                        if (*ppos != pos_tmp) {
+                                if (b_remain > 1) {
+                                        HERROR("unexpected file_pos dismatch: branch[%d] = %lu,  branch[%d] = %lu\n",
+                                                b_remain, (unsigned long)*ppos, b_remain - 1, (unsigned long)pos_tmp);
+                                } else {
+                                        HERROR("unexpected file_pos dismatch: branch[%d] = %lu,  parent = %lu\n",
+                                                b_remain, (unsigned long)*ppos, (unsigned long)pos_tmp);
+                                }
+                                LBUG();
+                        }
+#endif /* LIXI_20110725 */
+                        iov_free(iov_tmp, nrsegs_copy);
+                skip_writev:
+                        HDEBUG("writev end at branch[%d] \n", b_remain);
+                }
+#else /* LIXI_20110722 */
+#ifdef HAVE_FILE_WRITEV
+                retval = generic_file_writev(file, iov_copy, nrsegs_copy, ppos);
+#else
+                retval = generic_file_aio_write(iocb, iov_copy, nrsegs_copy,
+                                                *ppos);
+#endif
+#endif /* LIXI_20110722 */
+        } else {
+                /* lockless write
+                 *
+                 * current time will get into request as mtime and
+                 * ctime (swgfs/osc/osc_request.c:osc_build_request())
+                 */
+#ifndef LIXI_20110722
+                HERROR(" unexpted lockless readv at branch[%d]\n", b_remain);
+                LBUG();
+                retval = ll_file_lockless_io(file, iov_copy, nrsegs_copy,
+                                             ppos, WRITE, chunk);
+#else /* LIXI_20110722 */
+                retval = ll_file_lockless_io(file, iov_copy, nrsegs_copy,
+                                             ppos, WRITE, chunk);
+#endif /* LIXI_20110722 */
+        }
+        ll_rw_stats_tally(ll_i2sbi(inode), current->pid, file, chunk, 1);
+
+out_unlock:
+        if (tree_locked)
+                ll_tree_unlock(&tree);
+
+out:
+        if (retval > 0) {
+                count -= retval;
+                sum += retval;
+                if (retval == chunk && count > 0)
+                        goto repeat;
+        }
+
+        up(&ll_i2info(inode)->lli_write_sem);
+
+        if (iov_copy && iov_copy != iov)
+                OBD_FREE(iov_copy, sizeof(*iov) * nrsegs_orig);
+
+        retval = (sum > 0) ? sum : retval;
+        ll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_WRITE_BYTES,
+                           retval > 0 ? retval : 0);
+        RETURN(retval);
+}
+EXPORT_SYMBOL(ll_hrfs_file_writev);
+
+/* Trick generic_file_sendfile, let it ack like generic_file_readv, but no copy_to_user*/
+static int ll_hrfs_file_send_actor(read_descriptor_t *desc, struct page *page,
+			unsigned long offset, unsigned long size)
+{
+	unsigned long count = desc->count;
+
+	if (size > count)
+		size = count;
+
+	desc->count = count - size;
+	desc->written += size;
+
+	return size;
+}
+
+static ssize_t ll_hrfs_file_sendfile(struct file *parent_file, int b_remain, hrfs_f_branch_t *barray, loff_t *ppos,
+                                size_t count, read_actor_t actor, void *target)
+{
+        struct file *in_file = barray[0].bfile;
+        struct inode *inode = in_file->f_dentry->d_inode;
+        struct ll_inode_info *lli = ll_i2info(inode);
+        struct lov_stripe_md *lsm = lli->lli_smd;
+        struct ll_lock_tree tree;
+        struct ll_lock_tree_node *node;
+        struct ost_lvb lvb;
+        struct ll_ra_read bead;
+        ssize_t rc;
+        __u64 kms;
+        ENTRY;
+
+        CDEBUG(D_VFSTRACE, "VFS Op:inode=%lu/%u(%p),size="LPSZ",offset=%Ld\n",
+               inode->i_ino, inode->i_generation, inode, count, *ppos);
+
+        /* "If nbyte is 0, read() will return 0 and have no other results."
+         *                      -- Single Unix Spec */
+        if (count == 0)
+                RETURN(0);
+
+        ll_stats_ops_tally(ll_i2sbi(inode), LPROC_LL_READ_BYTES, count);
+        /* turn off the kernel's read-ahead */
+        in_file->f_ra.ra_pages = 0;
+
+        /* File with no objects, nothing to lock */
+        if (!lsm) {
+                rc = generic_file_sendfile(in_file, ppos, count, actor, target);
+                RETURN(rc);
+        }
+
+        node = ll_node_from_inode(inode, *ppos, *ppos + count - 1, LCK_PR);
+        if (IS_ERR(node))
+                RETURN(PTR_ERR(node));
+
+        tree.lt_fd = SWGFS_FPRIVATE(in_file);
+        rc = ll_tree_lock(&tree, node, NULL, count,
+                          in_file->f_flags & O_NONBLOCK?LDLM_FL_BLOCK_NOWAIT:0);
+        if (rc != 0)
+                RETURN(rc);
+
+        ll_clear_file_contended(inode);
+        ll_inode_size_lock(inode, 1);
+        /*
+         * Consistency guarantees: following possibilities exist for the
+         * relation between region being read and real file size at this
+         * moment:
+         *
+         *  (A): the region is completely inside of the file;
+         *
+         *  (B-x): x bytes of region are inside of the file, the rest is
+         *  outside;
+         *
+         *  (C): the region is completely outside of the file.
+         *
+         * This classification is stable under DLM lock acquired by
+         * ll_tree_lock() above, because to change class, other client has to
+         * take DLM lock conflicting with our lock. Also, any updates to
+         * ->i_size by other threads on this client are serialized by
+         * ll_inode_size_lock(). This guarantees that short reads are handled
+         * correctly in the face of concurrent writes and truncates.
+         */
+        inode_init_lvb(inode, &lvb);
+        obd_merge_lvb(ll_i2sbi(inode)->ll_osc_exp, lsm, &lvb, 1);
+        kms = lvb.lvb_size;
+        if (*ppos + count - 1 > kms) {
+                /* A glimpse is necessary to determine whether we return a
+                 * short read (B) or some zeroes at the end of the buffer (C) */
+                ll_inode_size_unlock(inode, 1);
+                rc = ll_glimpse_size(inode, LDLM_FL_BLOCK_GRANTED);
+                if (rc)
+                        goto out;
+#ifndef LIXI_20110420
+		kms = i_size_read(inode);
+#endif /* LIXI_20110420 */
+        } else {
+                /* region is within kms and, hence, within real file size (A) */
+                i_size_write(inode, kms);
+                ll_inode_size_unlock(inode, 1);
+        }
+
+        CDEBUG(D_INFO, "Send ino %lu, "LPSZ" bytes, offset %lld, i_size %llu\n",
+               inode->i_ino, count, *ppos, i_size_read(inode));
+
+        ll_ra_read_init(in_file, &bead, *ppos, count);
+        /* BUG: 5972 */
+        file_accessed(in_file);
+#ifndef LIXI_20110416
+	{
+		loff_t pos_tmp = *ppos;
+		/* Since tricked by ll_hrfs_file_send_actor, let target=NULL won't have problem */
+		rc = generic_file_sendfile(in_file, &pos_tmp, count, ll_hrfs_file_send_actor, NULL);
+	}
+	if (b_remain > 1) {
+		rc = ll_hrfs_file_sendfile(parent_file, b_remain - 1, &barray[1],
+				ppos, count, actor, target);
+	} else {
+		struct inode *parent_inode = parent_file->f_dentry->d_inode;
+
+		if (i_size_read(parent_inode) < kms) {
+			HDEBUG("Update isize to %lu, ppos = %lu, count  = %lu\n", (unsigned long)kms, (unsigned long)*ppos, (unsigned long)count);
+                    i_size_write(parent_inode, kms);
+		}
+		rc = generic_file_sendfile(parent_file, ppos, count, actor, target);
+
+	}
+#else
+        rc = generic_file_sendfile(in_file, ppos, count, actor, target);
+#endif
+
+        ll_ra_read_ex(in_file, &bead);
+
+ out:
+        ll_tree_unlock(&tree);
+        RETURN(rc);
+}
+EXPORT_SYMBOL(ll_hrfs_file_sendfile);
+
+int ll_hrfs_idata_init(struct inode *inode, struct inode *parent_inode, int is_primary)
+{
+        int rc = 0;
+        struct ll_inode_info *lli = ll_i2info(inode);
+        struct hrfs_idata *idata = &(lli->lli_hrfs_idata);
+
+        HDEBUG("idata initing\n");
+        /* $hi_parent is not NULL when renaming a file */
+        //LASSERT(idata->hi_parent == NULL);
+
+        idata->hi_parent = parent_inode;
+        if (is_primary) {
+                idata->hi_flag |= HRFS_FLAG_PRIMARY;
+        }
+
+        return rc;
+}
+EXPORT_SYMBOL(ll_hrfs_idata_init);
+
+int ll_hrfs_idata_finit(struct inode *inode)
+{
+        int rc = 0;
+        struct ll_inode_info *lli = ll_i2info(inode);
+        struct hrfs_idata *idata = &(lli->lli_hrfs_idata);
+
+        //LASSERT(idata->hi_parent);
+        if (idata->hi_parent == NULL) {
+                /* POSIX:24m is this situation*/
+                HDEBUG("hi_parent == NULL\n");
+        }
+        idata->hi_parent = NULL;
+        /* setattr? */
+
+        return rc;
+}
+EXPORT_SYMBOL(ll_hrfs_idata_finit);
+#endif /* LIXI_20110331 */
Index: swgfs-1.8.1.1/swgfs/llite/llite_internal.h
===================================================================
--- swgfs-1.8.1.1.orig/swgfs/llite/llite_internal.h
+++ swgfs-1.8.1.1/swgfs/llite/llite_internal.h
@@ -122,6 +122,43 @@ extern struct file_operations ll_pgcache
 #define LLI_F_CONTENDED                 2
 #define LLI_F_SRVLOCK                   3
 
+#ifndef LIXI_20110331
+struct hrfs_idata {
+        struct inode *hi_parent;
+        __u32 hi_flag;
+};
+
+static inline int hi_flag_is_valid(struct hrfs_idata *hi_data)
+{
+        int rc = 0;
+
+        if (hi_data->hi_parent == NULL) {
+                goto out;
+        }
+
+        rc = hrfs_flag_is_valid(hi_data->hi_flag);
+out:
+        return rc;
+}
+
+static inline int hi_is_primary(struct hrfs_idata *hi_data)
+{
+        return (hi_data->hi_flag & HRFS_FLAG_PRIMARY);
+}
+
+static inline int hi_is_proper(struct hrfs_idata *hi_data)
+{
+        return !(hi_data->hi_flag & HRFS_FLAG_DATABAD);
+}
+
+static inline int hi_is_primary_and_proper(struct hrfs_idata *hi_data)
+{
+        LASSERT(hi_data->hi_parent);
+        return hi_is_primary(hi_data) && hi_is_proper(hi_data);
+}
+
+#endif /* LIXI_20110331 */
+
 struct ll_inode_info {
         int                     lli_inode_magic;
         struct semaphore        lli_size_sem;           /* protect open and change size */
@@ -194,6 +231,9 @@ struct ll_inode_info {
         void                   *lli_follow_link_cookie_owner;
 #endif
 #endif
+#ifndef LIXI_20110331
+        struct hrfs_idata      lli_hrfs_idata;
+#endif /* LIXI_20110331 */
 };
 
 /*
