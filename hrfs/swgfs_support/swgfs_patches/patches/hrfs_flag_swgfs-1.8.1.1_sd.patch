Index: swgfs-1.8.1.1/swgfs/include/swgfs/swgfs_idl.h
===================================================================
--- swgfs-1.8.1.1.orig/swgfs/include/swgfs/swgfs_idl.h
+++ swgfs-1.8.1.1/swgfs/include/swgfs/swgfs_idl.h
@@ -709,6 +709,25 @@ out:
 }
 #endif /* LIXI_20110807 */
 
+#ifndef LIXI_20110807
+#define OBD_MD_FLHRFSFLAG     (0x0010000000000000ULL) /* hrfs flag, good for lustre-2.0 */
+
+#define MDS_BODY_HRFS_FLAG padding_4 /* use unused padding_4 of struct mds_body, should improve when lustre-2.0 */
+
+/*
+ * MDS_OPEN_HAS_OBJS is defined to 020000000000
+ * It is the 32th bit, so find a unused bit. Good for lustre-2.0
+ * Be carefull not to overlaped with open_flags
+ */
+#define MDS_HRFS_SET_FILE_FLAG	MDS_OPEN_DIRECTORY /* set when modifying file's hrfs_flag at mds */
+#define MDS_HRFS_SET_DIR_FLAG	MDS_OPEN_TRUNC     /* set when modifying dir's hrfs_flag at mds */
+
+/* Only used by mds */
+#define MDS_XATTR_NAME_HRFS_FLAG "trusted.hrfs.inode_flag"
+
+#define inode_is_locked(inode) mutex_is_locked(&(inode)->i_mutex)
+#endif /* LIXI_20110807 */
+
 /* don't forget obdo_fid which is way down at the bottom so it can
  * come after the definition of llog_cookie */
 
Index: swgfs-1.8.1.1/swgfs/llite/llite_lib.c
===================================================================
--- swgfs-1.8.1.1.orig/swgfs/llite/llite_lib.c
+++ swgfs-1.8.1.1/swgfs/llite/llite_lib.c
@@ -2497,6 +2497,19 @@ void ll_update_inode(struct inode *inode
 
         if (body->valid & OBD_MD_FLSIZE)
                 set_bit(LLI_F_HAVE_MDS_SIZE_LOCK, &lli->lli_flags);
+#ifndef LIXI_20110807
+        if (body->valid & OBD_MD_FLHRFSFLAG) {
+                __u32 hrfs_flag = body->MDS_BODY_HRFS_FLAG;
+                struct ll_inode_info *lli = ll_i2info(inode);
+                struct hrfs_idata *idata = &(lli->lli_hrfs_idata);
+
+                if (unlikely(!hrfs_flag_is_valid(hrfs_flag))) {
+                        HERROR("hrfs_flag 0x%x is not valid\n", hrfs_flag);
+                }
+                idata->hi_flag = hrfs_flag;
+                HDEBUG("updating inode's hrfs_flag to 0x%x\n", hrfs_flag);
+        }
+#endif /* LIXI_20110807 */
         EXIT;
 }
 
@@ -2943,3 +2956,95 @@ int ll_show_options(struct seq_file *seq
 
         RETURN(0);
 }
+
+#ifndef LIXI_20110807
+int ll_hrfs_inode_get_flag(struct inode *inode, __u32 *hrfs_flag)
+{
+        int rc = 0;
+        struct ll_sb_info *sbi = ll_i2sbi(inode);
+        struct ptlrpc_request *req = NULL;
+        struct ll_fid fid;
+        struct mds_body *body = NULL;
+
+        ll_inode2fid(&fid, inode);
+        rc = mdc_getattr(sbi->ll_mdc_exp, &fid, OBD_MD_FLHRFSFLAG, 0, &req);
+        if (rc) {
+                CERROR("swgfs_hrfs: failure %d inode %lu\n", rc, inode->i_ino);
+                goto out;
+        }
+
+        body = swgfs_msg_buf(req->rq_repmsg, REPLY_REC_OFF, sizeof(*body));
+        LASSERT(body != NULL); /* checked by mdc_getattr_name */
+        /* swabbed by mdc_getattr_name */
+        LASSERT(swgfs_rep_swabbed(req, REPLY_REC_OFF));
+
+		if (body->valid | OBD_MD_FLHRFSFLAG) {
+        	*hrfs_flag = body->MDS_BODY_HRFS_FLAG;
+        } else {
+        	CERROR("swgfs_hrfs: fail to get flag, valid = 0x%llx, hrfs_flag = 0x%x\n", body->valid, body->MDS_BODY_HRFS_FLAG);
+        	rc = -EIO;
+        	goto finish_req;
+        }
+
+        rc = ll_prep_inode(sbi->ll_osc_exp, &inode, req, REPLY_REC_OFF, NULL);
+
+finish_req:
+        ptlrpc_req_finished(req);
+ out:
+        return rc;
+}
+EXPORT_SYMBOL(ll_hrfs_inode_get_flag);
+
+int ll_hrfs_inode_set_flag(struct inode *inode, __u32 hrfs_flag)
+{
+        int rc = 0;
+        struct ll_sb_info *sbi = ll_i2sbi(inode);
+        struct ll_iattr_struct attr;
+        struct mdc_op_data op_data = { { 0 } };
+        struct ptlrpc_request *req = NULL;
+        struct swgfs_md md;
+
+        if (unlikely(!(S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)))) {
+                rc = -EBADF;
+                goto out;
+        }
+
+        if (unlikely(!hrfs_flag_is_valid(hrfs_flag))) {
+                rc = -EPERM;
+                goto out;
+        }
+
+        ll_prepare_mdc_op_data(&op_data, inode, NULL, NULL, 0, 0, NULL);
+
+        memset(&attr, 0, sizeof(attr));
+        if (S_ISREG(inode->i_mode)) {
+                attr.ia_attr_flags |= MDS_HRFS_SET_FILE_FLAG;
+        } else {
+                /* is dir */
+                attr.ia_attr_flags |= MDS_HRFS_SET_DIR_FLAG;
+        }
+
+        rc = mdc_setattr(sbi->ll_mdc_exp, &op_data,
+                         (struct iattr *)&attr, &hrfs_flag, sizeof(hrfs_flag), NULL, 0, &req);
+        if (rc) {
+                ptlrpc_req_finished(req);
+                if (rc != -EPERM && rc != -EACCES) {
+                        CERROR("mdc_setattr fails: rc = %d\n", rc);
+                }
+                goto out;
+        }
+
+        /* Set successfully, update local flag of inode */
+        rc = mdc_req2swgfs_md(req, REPLY_REC_OFF, sbi->ll_osc_exp, &md);
+        if (rc) {
+                ptlrpc_req_finished(req);
+                goto out;
+        }
+
+        ll_update_inode(inode, &md);
+        ptlrpc_req_finished(req);
+out:
+        return rc;
+}
+EXPORT_SYMBOL(ll_hrfs_inode_set_flag);
+#endif /* LIXI_20110807 */
Index: swgfs-1.8.1.1/swgfs/mds/mds_internal.h
===================================================================
--- swgfs-1.8.1.1.orig/swgfs/mds/mds_internal.h
+++ swgfs-1.8.1.1/swgfs/mds/mds_internal.h
@@ -48,8 +48,27 @@
 
 #define MAX_ATIME_DIFF 60
 
+#ifndef LIXI_20110810
+//#define HAVE_HRFS_FLAG_INODE_CACHE 1
+
+#ifdef HAVE_HRFS_FLAG_INODE_CACHE
+struct mds_hrfs_filter_data {
+        __u32 mds_hrfs_flag;
+};
+
+#define MDS_HRFS_FILTER_DATA(inode) (MDS_FILTERDATA(inode)->mds_hrfs_filter_data)
+#define MDS_HRFS_FILTER_FLAG(inode) (MDS_HRFS_FILTER_DATA(inode).mds_hrfs_flag)
+
+#endif /* HAVE_HRFS_FLAG_INODE_CACHE */
+#endif /* LIXI_20110810 */
+
 struct mds_filter_data {
         __u64 io_epoch;
+#ifndef LIXI_20110810
+#ifdef HAVE_HRFS_FLAG_INODE_CACHE
+        struct mds_hrfs_filter_data mds_hrfs_filter_data;
+#endif /* HAVE_HRFS_FLAG_INODE_CACHE */
+#endif /* LIXI_20110810 */
 };
 
 #define MDS_FILTERDATA(inode) \
Index: swgfs-1.8.1.1/swgfs/mds/mds_lib.c
===================================================================
--- swgfs-1.8.1.1.orig/swgfs/mds/mds_lib.c
+++ swgfs-1.8.1.1/swgfs/mds/mds_lib.c
@@ -68,6 +68,87 @@ static void mds_pack_inode2fid(struct ll
         fid->f_type = (S_IFMT & inode->i_mode);
 }
 
+#ifndef LIXI_20110809
+
+static int mds_get_hrfs_flag(struct inode *inode, __u32 *hrfs_flag)
+{
+        int rc = 0;
+        struct dentry de = { .d_inode = inode };
+        int need_unlock = 0;
+        __u32 mds_flag = 0;
+
+        LASSERT(inode);
+        if (!inode_is_locked(inode)) {
+                /* May be called from mds_reint_setattr() holding inode lock */
+                LOCK_INODE_MUTEX(inode);
+                need_unlock = 1;
+        }
+
+#ifdef HAVE_HRFS_FLAG_INODE_CACHE
+        /* Get from inode cache */
+        mds_flag = MDS_HRFS_FILTER_FLAG(inode);
+        if (mds_hrfs_flag_is_valid(mds_flag)) {
+                CERROR("swgfs_hrfs: use mds_hrfs_flag in inode cache\n");
+                *hrfs_flag = mds_flag;
+                goto out;
+        }
+#endif
+
+        if (unlikely((!inode->i_op || !inode->i_op->getxattr))) {
+                rc = -EPERM;
+                goto out;
+        }
+
+        rc = inode->i_op->getxattr(&de, MDS_XATTR_NAME_HRFS_FLAG,
+                                   &mds_flag, sizeof(mds_flag));
+        if (unlikely(rc != sizeof(mds_flag))) {
+                if (rc >= 0) {
+                        CERROR("swgfs_hrfs: rc = %d, expect %ld\n", rc, sizeof(mds_flag));
+                        rc = -EINVAL;
+                }
+                goto out;
+        }
+
+        if (unlikely(!mds_hrfs_flag_is_valid(mds_flag))) {
+                CERROR("swgfs_hrfs: mds_hrfs_flag 0x%x is not valid\n", mds_flag);
+                rc = -EIO;
+                goto out;
+        }
+
+#ifdef HAVE_HRFS_FLAG_INODE_CACHE
+        /* Update inode cache */
+        MDS_HRFS_FILTER_FLAG(inode) = mds_flag;
+#endif
+
+        *hrfs_flag = mds_flag & HRFS_FLAG_MDS_MASK;
+        CDEBUG(D_HA, "swgfs_hrfs: rc = %d, hrfs_flag = 0x%x\n", rc, *hrfs_flag);
+out:
+        if (need_unlock) {
+                UNLOCK_INODE_MUTEX(inode);
+        }
+        return rc;
+}
+
+static void mds_pack_hrfs_flag2body(struct mds_body *b, struct inode *inode)
+{
+        int rc = 0;
+        __u32 hrfs_flag = 0;
+
+        rc = mds_get_hrfs_flag(inode, &hrfs_flag);
+        if (rc < 0) {
+                goto out;
+        }
+
+        b->MDS_BODY_HRFS_FLAG = hrfs_flag;
+        b->valid |= OBD_MD_FLHRFSFLAG;
+
+        CDEBUG(D_HA, "swgfs_hrfs: packing hrfs_flag = 0x%x\n", hrfs_flag);
+out:
+        return;
+}
+
+#endif /* LIXI_20110809 */
+
 /* Note that we can copy all of the fields, just some will not be "valid" */
 void mds_pack_inode2body(struct mds_body *b, struct inode *inode)
 {
@@ -102,6 +183,11 @@ void mds_pack_inode2body(struct mds_body
         b->nlink = mds_inode_is_orphan(inode) ? 0 : inode->i_nlink;
         b->generation = inode->i_generation;
         b->suppgid = -1;
+#ifndef LIXI_20110809
+        if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode)) {
+                mds_pack_hrfs_flag2body(b, inode);
+        }
+#endif /* LIXI_20110809 */
 }
 
 static inline unsigned int attr_unpack(__u64 sa_valid) {
Index: swgfs-1.8.1.1/swgfs/mds/mds_reint.c
===================================================================
--- swgfs-1.8.1.1.orig/swgfs/mds/mds_reint.c
+++ swgfs-1.8.1.1/swgfs/mds/mds_reint.c
@@ -797,6 +797,46 @@ static int mds_log_file_lost_data(struct
 }
 #endif
 
+#ifndef LIXI_20110807
+
+int mds_set_hrfs_flag(struct inode *inode, __u32 hrfs_flag)
+{
+        int rc = 0;
+        struct dentry de = { .d_inode = inode };
+        int flag = 0; /* Should success all the time, so NO XATTR_CREATE or XATTR_REPLACE */
+        __u32 mds_flag = 0;
+
+        LASSERT(inode);
+        LASSERT(inode_is_locked(inode));
+
+        if(unlikely(!hrfs_flag_is_valid(hrfs_flag))) {
+                CERROR("swgfs_hrfs: 0x%x is not a valid hrfs_flag\n", hrfs_flag);
+                rc = -EPERM;
+                goto out;
+        }
+
+        mds_flag = hrfs_flag | HRFS_FLAG_MDS_SYMBOL;
+
+        if (unlikely(!inode->i_op || !inode->i_op->setxattr)) {
+                rc = -EPERM;
+                goto out;
+        }
+
+        rc = inode->i_op->setxattr(&de, MDS_XATTR_NAME_HRFS_FLAG,
+                                   &mds_flag, sizeof(mds_flag), flag);
+        if (rc != 0) {
+                CERROR("swgfs_hrfs: setxattr failed, rc = %d\n", rc);
+                goto out;
+        }
+#ifdef HAVE_HRFS_FLAG_INODE_CACHE
+        /* Update inode cache */
+        MDS_HRFS_FILTER_FLAG(inode) = mds_flag;
+#endif
+out:
+        return rc;
+}
+#endif /* LIXI_20110807 */
+
 /* In the raw-setattr case, we lock the child inode.
  * In the write-back case or if being called from open, the client holds a lock
  * already.
@@ -944,6 +984,30 @@ static int mds_reint_setattr(struct mds_
                 struct lov_stripe_md *lsm = NULL;
                 struct lov_user_md *lum = NULL;
 
+#ifndef LIXI_20110825
+                if ((S_ISREG(inode->i_mode) && rec->ur_flags & MDS_HRFS_SET_FILE_FLAG) ||
+                    (S_ISDIR(inode->i_mode) && rec->ur_flags & MDS_HRFS_SET_DIR_FLAG)) {
+                        __u32 hrfs_flag = *((__u32 *)rec->ur_eadata);
+
+                        CERROR("swgfs_hrfs: rec->ur_flags = 0x%x, rec->ur_eadata = 0x%x\n",
+                               rec->ur_flags, hrfs_flag);
+                        /*
+                         * May be must reply to client whether setting is suceessful.
+                         * And then, clint set its own flag.
+                         * Never mind, jut do it simple now.
+                         */
+                        rc = mds_set_hrfs_flag(inode, hrfs_flag);
+                        if (rc < 0) {
+                                GOTO(cleanup, rc);
+                                if (0) {
+                                        mds_log_file_with_bad_stripe(NULL, NULL);
+                        	            mds_log_file_lost_data(NULL, NULL);
+                        	    }
+                        }
+                        goto setflag_done;
+                }
+#endif /* LIXI_20110825 */
+
                 rc = ll_permission(inode, MAY_WRITE, NULL);
                 if (rc < 0)
                         GOTO(cleanup, rc);
@@ -1109,6 +1173,10 @@ cleanup_md:
                 }
         }
 
+#ifndef LIXI_20110825
+setflag_done:
+#endif /* LIXI_20110825 */
+
         body = swgfs_msg_buf(req->rq_repmsg, offset, sizeof(*body));
         mds_pack_inode2body(body, inode);
 
