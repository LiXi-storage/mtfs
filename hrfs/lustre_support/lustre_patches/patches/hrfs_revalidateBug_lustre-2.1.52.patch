Index: lustre-2.1.52/lustre/llite/dcache.c
===================================================================
--- lustre-2.1.52.orig/lustre/llite/dcache.c	2012-01-09 20:15:31.000000000 +0800
+++ lustre-2.1.52/lustre/llite/dcache.c	2012-03-09 16:27:59.000000000 +0800
@@ -395,6 +395,7 @@
 
 }
 
+#include <hrfs/debug.h>
 int ll_revalidate_it(struct dentry *de, int lookup_flags,
                      struct lookup_intent *it)
 {
@@ -408,7 +409,14 @@
         ENTRY;
         CDEBUG(D_VFSTRACE, "VFS Op:name=%s,intent=%s\n", de->d_name.name,
                LL_IT2STR(it));
-
+if (de->d_inode) {
+	if (it) {
+		HERROR("it.it_op = %x\n", it->it_op);
+	} else {
+		HERROR("ititititititiit is NULL\n");
+	}
+	HERROR("i_mode = %o\n", de->d_inode->i_mode);
+}
         if (de->d_inode == NULL) {
                 __u64 ibits;
 
@@ -427,7 +435,7 @@
                 rc = ll_have_md_lock(parent, &ibits, LCK_MINMODE);
                 GOTO(out_sa, rc);
         }
-
+HERROR("1\n");
         /* Never execute intents for mount points.
          * Attributes will be fixed up in ll_inode_revalidate_it */
         if (d_mountpoint(de))
@@ -440,16 +448,19 @@
                         rc = 1;
                 GOTO(out_sa, rc);
         }
-
+HERROR("2\n");
         exp = ll_i2mdexp(de->d_inode);
 
         OBD_FAIL_TIMEOUT(OBD_FAIL_MDC_REVALIDATE_PAUSE, 5);
         ll_frob_intent(&it, &lookup_it);
         LASSERT(it);
-
-        if (it->it_op == IT_LOOKUP && !(de->d_flags & DCACHE_LUSTRE_INVALID))
+HERROR("it.it_op = %x\n", it->it_op);
+HERROR("3\n");
+        if (it->it_op == IT_LOOKUP && !(de->d_flags & DCACHE_LUSTRE_INVALID)) {
+        	HERROR("3.1\n");
                 RETURN(1);
-
+	}
+HERROR("4\n");
         if ((it->it_op == IT_OPEN) && de->d_inode) {
                 struct inode *inode = de->d_inode;
                 struct ll_inode_info *lli = ll_i2info(inode);
@@ -499,14 +510,15 @@
                         cfs_up(&lli->lli_och_sem);
                 }
         }
-
+HERROR("5\n");
         if (it->it_op == IT_GETATTR) {
                 rc = ll_statahead_enter(parent, &de, 0);
                 if (rc == 1)
                         goto mark;
         }
-
+HERROR("6\n");
 do_lock:
+HERROR("7\n");
         op_data = ll_prep_md_op_data(NULL, parent, de->d_inode,
                                      de->d_name.name, de->d_name.len,
                                      0, LUSTRE_OPC_ANY, NULL);
@@ -521,7 +533,7 @@
                             &req, ll_md_blocking_ast, 0);
         it->it_create_mode &= ~M_CHECK_STALE;
         ll_finish_md_op_data(op_data);
-
+HERROR("8\n");
         /* If req is NULL, then md_intent_lock only tried to do a lock match;
          * if all was well, it will return 1 if it found locks, 0 otherwise. */
         if (req == NULL && rc >= 0) {
@@ -537,7 +549,7 @@
                 }
                 GOTO(out, rc = 0);
         }
-
+HERROR("9\n");
 revalidate_finish:
         rc = ll_revalidate_it_finish(req, it, de);
         if (rc != 0) {
@@ -545,14 +557,14 @@
                         ll_intent_release(it);
                 GOTO(out, rc = 0);
         }
-
+HERROR("10\n");
         if ((it->it_op & IT_OPEN) && de->d_inode &&
             !S_ISREG(de->d_inode->i_mode) &&
             !S_ISDIR(de->d_inode->i_mode)) {
                 ll_release_openhandle(de, it);
         }
         rc = 1;
-
+HERROR("11\n");
         /* unfortunately ll_intent_lock may cause a callback and revoke our
          * dentry */
         ll_dentry_rehash(de, 0);
@@ -579,7 +591,7 @@
                 ll_dentry_reset_flags(de, bits);
                 ll_lookup_finish_locks(it, de);
         }
-
+HERROR("12\n");
 mark:
         if (it != NULL && it->it_op == IT_GETATTR && rc > 0)
                 ll_statahead_mark(parent, de);
@@ -608,7 +620,7 @@
                 ll_lookup_finish_locks(it, de);
                 it = &lookup_it;
         }
-
+HERROR("13\n");
         /* Do real lookup here. */
         op_data = ll_prep_md_op_data(NULL, parent, NULL, de->d_name.name,
                                      de->d_name.len, 0, (it->it_op & IT_CREAT ?
@@ -641,7 +653,7 @@
         }
         ll_finish_md_op_data(op_data);
         GOTO(out, rc = 0);
-
+HERROR("14\n");
 out_sa:
         /*
          * For rc == 1 case, should not return directly to prevent losing
@@ -657,9 +669,15 @@
         int rc;
         ENTRY;
 
+	HDEBUG("nd 1\n");
+	if (nd) {
+		HDEBUG("nd is NOT null\n");
+	} else {
+		HDEBUG("nd is null\n");
+	}
         if (nd && !(nd->flags & (LOOKUP_CONTINUE|LOOKUP_PARENT))) {
                 struct lookup_intent *it;
-
+		HDEBUG("nd 2\n");
                 it = ll_convert_intent(&nd->intent.open, nd->flags);
                 if (IS_ERR(it))
                         RETURN(0);
@@ -670,7 +688,7 @@
                         rc = 0;
                         goto out_it;
                 }
-
+		HDEBUG("nd 3\n");
                 rc = ll_revalidate_it(dentry, nd->flags, it);
 
                 if (rc && (nd->flags & LOOKUP_OPEN) &&
@@ -721,6 +739,7 @@
                         OBD_FREE(it, sizeof(*it));
                 }
         } else {
+        	HDEBUG("nd 4\n");
                 rc = ll_revalidate_it(dentry, 0, NULL);
         }
 
